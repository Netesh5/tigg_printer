# ESC/POS Integration Guide

This guide shows how to integrate the `tigg_printer` plugin with your existing `esc_pos_utils_plus` workflow without changing your application flow.

## Overview

The `tigg_printer` plugin now supports printing raw byte data through the `printRawBytes()` method, making it compatible with ESC/POS command bytes generated by the `esc_pos_utils_plus` package.

**âœ… FIXED:** Raw bytes are now sent directly to the printer hardware, preserving all ESC/POS formatting, alignment, font sizes, bold text, underlines, and other styling commands.

## Key Features

- **Direct ESC/POS command execution** - No bitmap conversion, commands go straight to printer
- **Full formatting preservation** - Bold, underline, font sizes, alignment all work correctly  
- **No unwanted characters** - ESC/POS control codes are properly interpreted by printer
- **All alignments supported** - Left, center, right alignment commands work as expected
- **Complete compatibility** - Works with all `esc_pos_utils_plus` generated commands

## Integration Example

Here's how you can use your existing ESC/POS utilities with the thermal printer:

```dart
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:tigg_printer/tigg_printer.dart';

class ThermalPrinterService {
  /// Print using your existing ESC/POS workflow
  Future<void> printReceipt() async {
    // 1. Create your ESC/POS commands using esc_pos_utils_plus (your existing code)
    final Generator generator = Generator(PaperSize.mm58);
    List<int> bytes = [];
    
    // Add your existing ESC/POS commands
    bytes += generator.reset();
    bytes += generator.text('Store Receipt', 
      styles: const PosStyles(align: PosAlign.center, height: PosTextSize.size2));
    bytes += generator.text('Date: ${DateTime.now().toString().substring(0, 19)}');
    bytes += generator.hr();
    bytes += generator.text('Item 1................\$10.00');
    bytes += generator.text('Item 2................\$15.00');
    bytes += generator.hr();
    bytes += generator.text('TOTAL: \$25.00', 
      styles: const PosStyles(bold: true));
    bytes += generator.feed(2);
    bytes += generator.cut();
    
    // 2. Print using the thermal printer (NEW - just replace your BT printing)
    try {
      final result = await TiggPrinter.printRawBytes(bytes: bytes);
      print('Print successful: ${result.message}');
    } catch (e) {
      print('Print failed: $e');
    }
  }
  
  /// Your existing method - just change the printing part
  Future<void> printBarcode(String barcodeData) async {
    final Generator generator = Generator(PaperSize.mm58);
    List<int> bytes = [];
    
    bytes += generator.reset();
    bytes += generator.text('Product Code:', styles: const PosStyles(align: PosAlign.center));
    bytes += generator.barcode(Barcode.code128(barcodeData));
    bytes += generator.text(barcodeData, styles: const PosStyles(align: PosAlign.center));
    bytes += generator.feed(3);
    bytes += generator.cut();
    
    // Replace your BT printing code with this:
    await TiggPrinter.printRawBytes(bytes: bytes);
  }
}
```

## Key Benefits

1. **No workflow changes**: Your existing ESC/POS command generation remains the same
2. **Drop-in replacement**: Just replace your Bluetooth printing call with `TiggPrinter.printRawBytes()`
3. **Full ESC/POS compatibility**: All commands, barcodes, formatting work as before
4. **Better reliability**: Hardware-direct printing instead of Bluetooth connection issues

## Migration Steps

1. **Keep your existing code**: All your ESC/POS command generation stays the same
2. **Replace printing method**: Change from BT printing to `TiggPrinter.printRawBytes(bytes: yourBytes)`
3. **Add service binding**: Add `TiggPrinter.bindServiceWithRetry()` at app startup
4. **Handle results**: Use the returned `PrintResult` for success/error handling

## Example Migration

**Before (with Bluetooth):**
```dart
// Your existing code
List<int> bytes = generateEscPosCommands();

// Old BT printing
await bluetoothPrint.writeBytes(bytes);
```

**After (with TiggPrinter):**
```dart
// Your existing code (unchanged)
List<int> bytes = generateEscPosCommands();

// New thermal printer (direct hardware)
final result = await TiggPrinter.printRawBytes(bytes: bytes);
```

## Complete Working Example

```dart
import 'package:flutter/material.dart';
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:tigg_printer/tigg_printer.dart';

class PrintService {
  static Future<void> initialize() async {
    try {
      await TiggPrinter.bindServiceWithRetry(maxRetries: 3);
      print('Thermal printer service ready');
    } catch (e) {
      print('Failed to initialize printer service: $e');
    }
  }
  
  static Future<bool> printSalesReceipt({
    required String storeName,
    required List<Map<String, dynamic>> items,
    required double total,
  }) async {
    try {
      // Generate ESC/POS commands (your existing logic)
      final Generator generator = Generator(PaperSize.mm58);
      List<int> bytes = [];
      
      // Header
      bytes += generator.reset();
      bytes += generator.text(storeName, 
        styles: const PosStyles(
          align: PosAlign.center, 
          height: PosTextSize.size2,
          bold: true
        ));
      bytes += generator.text('Sales Receipt', 
        styles: const PosStyles(align: PosAlign.center));
      bytes += generator.text('Date: ${DateTime.now().toString().substring(0, 19)}');
      bytes += generator.hr();
      
      // Items
      for (var item in items) {
        String line = '${item['name']}';
        String price = '\$${item['price'].toStringAsFixed(2)}';
        int maxWidth = 32;
        int dots = maxWidth - line.length - price.length;
        if (dots > 0) line += '.' * dots;
        line += price;
        bytes += generator.text(line);
      }
      
      // Total
      bytes += generator.hr();
      bytes += generator.text('TOTAL: \$${total.toStringAsFixed(2)}', 
        styles: const PosStyles(bold: true, height: PosTextSize.size2));
      bytes += generator.feed(3);
      bytes += generator.cut();
      
      // Print using thermal printer
      final result = await TiggPrinter.printRawBytes(bytes: bytes);
      return result.success;
      
    } catch (e) {
      print('Print error: $e');
      return false;
    }
  }
}
```

This approach allows you to maintain your existing application structure while leveraging the reliable thermal printer hardware instead of dealing with Bluetooth connection issues.
